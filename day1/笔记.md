李响
928419197  qq

1周node   mvc后台管理
3周 vue  重点***
2/3react 周
1-2 微信相关 小程序、多端框架（app、各种小程序、h5）、微信公众号
查漏补缺：地图api、ehcarts、better-scroll

## node 对于前端意义
node：基于 chrome v8引擎 js 运行环境（独立安装的js运行环境）
浏览器 解析 网页 内核
内容排版引擎   解析 html/css
js解释引擎 解析js

## nvm安装以及使用
```
nvm ls 列举当前可用的node列表
nvm install 6.14.4
nvm use 版本
```
## 复习npm 
node是js 运行环境（独立安装 安装到 服务器上）
node就可以操作 服务器 相关 资源（数据库、当做服务器软件、操作硬件）
node可以取代java php做 后端服务
目前前端用node最大的意义：
  基于node 构建前端自动化 开发环境  （gulp）
  vue+webpack react+webpack       webpack
```
npm node 包管理器
启动项目
  npm init [--yes]
  npm install 包名[@版本号][-g][--save/--save-dev]
                                 -S     -D
  npm uninstall 包名[-g]
  npm info 包名

  package.json  项目配置文件
  scripts:{
    "脚本":"命令"
  }

  运行脚本：
    npm run 脚本名
    npm install 


    https://www.npmjs.com/   npm服务器 可视化窗口地址

  npm 淘宝镜像
    cnpm 
    安装
        npm install -g cnpm --registry=https://registry.npm.taobao.org

  nrm  切换npm 源
    npm i nrm -g
    nrm 
```

## yarn 包管理器
yarn yarn lock（锁定安装版本）
```
cnpm i yarn -g
yarn init  初始化项目 生成package.json
yarn add 包名[@版本号][--global][--dev]
yarn add 包名 默认是安装的生产环境依赖 npm install 包名 -S 
yarn remove 包名[--global]
yarn （读取package.json中的生产、开发依赖 安装）
```
## node模块
+ nodejs 全局模块
```
引入
  const fs = require('fs') // 直接写模块名即可
使用
  fs.readFile(xx,xx)
```
+ 独立安装第三方模块 （npm下载） 在 node_modules
```
下载
npm i body-parser -S
引入
const bodyParser = require('body-parser')  // 直接写模块名

使用
  bodyParser.json()

```
+ 自定义模块
```
nodejs模块
  1，如果一个文件.js 没有向外提供接口
  那么整个文件就是一个模块，可以直接引入这个文件（相当于将这个文件的代码直接copy进来）
  注意：模块化 每个模块是有自己单独的作用域（多个模块中的变量名可以一样）
  2，模块化 接口
   1) 一个文件 向外提供多个接口
    exports.a = 值
    exports.b = 值
    exports.x = 值
    值可以是任意数据类型

    引入 （全部引入 obj是一个对象）
    const obj = require('./a.js')

    或者  引入特定接口
    const { a,b } = require('./a.js')
    注意：
      自定义的接口 即使和 引入 文件在同一目录下，也不要直接写目录名
      node中require机制（如果直接写目录名，node会先去自己的模块中查找，再去node_modules中插件如果都没有 会直接报错）
   2）一个文件 默认提供接口（只能提供一个）
      module.exports = 值
    注意：
      这个文件只能导出一个接口
    注意：
      当一个文件中出现了
      module.exports 和 exports 以module.exports为准
    建议使用module.exports
```

## node 常用内置模块 
+ fs 文件系统 读 写 删除 更新
```
异步

读文件

const fs = fs.readFile(path[,options],callback)
callback:
  err
  data
写
fs.writeFile(path,data[,options],callback)
callback
  err

追加
fs.appendFile(path,data[,options],callback)
callback
  err

删除  
fs.unlink(path,callback)
```
## path模块
```
path.join([...path])
// 方法 可以有多个参数，或者没有参数 
// 将 方法的 参数 拼接成 路径片段

path.resolve([...path])

// 解析 路径参数 解析成 绝对路径
注意：
  /写在路径前面代表 根目录
  有服务器（软件）：
    /根目录就是服务器监听目录
  没有服务器：
    当前文件所在 的盘
```

## nodejs 内置的全局变量
```
__dirname
  当前文件所在目录的绝对路径
  path.join(__dirname,'../fs')
__filename
  当前文件所在的绝对路径
```

## url模块
```
组件
  协议名
  主机
  端口
  path
  search  (包含query  k=v&k2=v2)
  hash （#hash）

  parse()
  format()
```

## http/https

const https = require('https')
const cheerio = require('cheerio')
const targetUrl = "https://image.baidu.com/search/index?tn=baiduimage&ipn=r&ct=201326592&cl=2&lm=-1&st=-1&fm=index&fr=&hs=0&xthttps=111111&sf=1&fmq=&pv=&ic=0&nc=1&z=&se=1&showtab=0&fb=0&width=&height=&face=0&istype=2&ie=utf-8&word=%E7%BE%8E%E5%A5%B3&oq=%E7%BE%8E%E5%A5%B3&rsp=-1"
https.get(targetUrl,(res) => {
  res.setEncoding('utf8');
  let rawData = '';
  let imgArr = []
  res.on('data', (chunk) => { 
    rawData += chunk
  });
  res.on('end', () => {   
    console.log("数据全部传输完毕了")
    
    const $ = cheerio.load(rawData)

    console.log($('img').attr('src'))

    $("img").each((i,ele)=>{
      imgArr.push($(ele).attr('src'))
    })


    console.log(imgArr)
    /* 
    分析 rawdata中
    img标签
    src拿出来

    $("img").each((i,el)=>{

    })
    */
  });
}).on('error', (e) => {
  console.error(`出现错误: ${e.message}`);
})





在node中 发送一个http请求或者 https
爬虫：
  1，确定目标
  2，爬取 图片 
  3，url（图片地址拿出来）

https://image.baidu.com/search/index?tn=baiduimage&ipn=r&ct=201326592&cl=2&lm=-1&st=-1&fm=index&fr=&hs=0&xthttps=111111&sf=1&fmq=&pv=&ic=0&nc=1&z=&se=1&showtab=0&fb=0&width=&height=&face=0&istype=2&ie=utf-8&word=%E7%BE%8E%E5%A5%B3&oq=%E7%BE%8E%E5%A5%B3&rsp=-1

有道云笔记 

